-- 학습 계획 --
주말 >> 배운 내용 정리, 밀린 내용 학습 
시험 기간에는 배운 내용 복습 정도만 가능할듯,, 

알고_주 2~3문제
바킹독_주 1~2강(연습문제도 있음)
C,C++_주 2~3 chapter씩 하기

알고리즘_https://velog.io/@ngngs/%ED%95%9C-%EC%9E%A5%EC%9C%BC%EB%A1%9C-%EB%B3%B4%EB%8A%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98
파트1: 7개, 2: 16개, 3: 16개, 4: 12개
총 51문제
>> 4개월 

바킹독_https://blog.encrypted.gg/919
31강
>> 4개월
문제 링크_https://github.com/encrypted-def/basic-algo-lecture/blob/master/workbook.md
연습 문제 0x02강_1267번 이어서, 0x03강_처음부터

모코_C,C++_https://modoocode.com/231
C: 23강, C++: 22강
총 45챕터
>> 4개월 
--------------
0902 
바킹독 0x02강

-- 바킹독 0x02강_기초코드 작성 요령2 -- 
- STL과 함수 인자 
STL(Standard Template Library) >> C++에서 제공되는 라이브러리 

- 표준 입출력
- scanf, cin 모두 공백 앞까지만 입력을 받는다.
이를 해결하기 위한 방법: getline 이용, 조건: type이 C++ string이어야함 
string s;
getline(cin,s);
cout << s;

-- ios::sync_with_stdio(0)
C stream과 C++ stream의 동기화를 끊어버림으로 수행 시간에서 이득을 보는 방식
다만, 이렇게 동기화를 끊으면 cout과 printf를 섞어쓰면 안된다
섞어쓰면 코드출력 결과의 순서가 꼬이게 될 수 있음

-- cin.tie(0)
화면에 글자를 출력하기 위해서는 입력 > buffer > console의 과정을 거친다
cin 명령 수행 전에 cout 버퍼를 비우지 않도록 하는 코드가
cin.tie(0)임

 결론: cin/cout 쓸 때는 
 ios::sync_with_stdio(0)
 cin.tie(0)을 무조건 쓰기
 그리고, cin/cout만 쓰고, printf/scanf는 사용 XX

-- endl >> 절대 사용 XXXX
명령: 개행 문자를 출력하고 출력 버퍼를 비우라는 명령
쓰지 말고, 그냥 개행 문자 출력하기("\n")

- 코딩테스트와 개발의 차이
코테는 내가 빠르게 짤수 있는 방식으로 빠르게 구현하는 게 핵심
클린 코드가 중요한 게 아니다 

- TIP 
출력 맨 마지막에 공백/줄바꿈이 추가로 있어도 상관없음
디버거는 굳이 사용하지 않아도 된다 

-- 바킹독 연습 문풀 --
>>>>2309부터 이어서 
- 2752_세 수 정렬
sort 함수 활용법
sort(start, end);
- 2756_홀수
if, else문 활용할 때
관련 조건의 명령 코드가 1줄 일 때는 {}없이 사용해도 문제가 없으나
2줄 이상일 때는 {} 필수로 넣어야함

-- 모두의 코드 C -- 
- 2-3_컴퓨터가 수를 표현하는 방법_이진법
RAM(Read Access Memory): 컴퓨터에서 데이터를 잠시 기록해놓는 것이 메모리
(휘발성 메모리, 매우 빠르다)

1byte = 8bit
1nibble = 4bit
레지스터(작은 메모리 공간)에서 연산을 수행하는데
레지스터의 크기를 연산이 실행되는 최소 단위라 할 수 있다
64비트 컴퓨터 = 1word가 64비트
32비트 컴퓨터는 =1 word가 32비트

- 3.변수가 뭐지?
%o: 8진수
%d: 10진수
%x: 16진수 표현 

- 변수 선언 시 주의사항
float,double 모두 %f 선언
다만
float a = 3.1235;
double b = 1245;
이런 식으로 작성하면 a도 double으로 저장이 된다
따라서, 
float 선언 시에는
flaot a = 3.1235f;
처럼 ";"을 붙여서 선언하기 

-- 알고리즘 -- 
- 9663_N-Queen
vector<int> board;
>> 동적 배열인 벡터<int>로 선언
"벡터"는 크기가 고정된 일반 배열과 다르게 크기를 동적으로 변경할 수 있다

resize(num)
>> 벡터의 크기를 "num"으로 변경함
board=[0,0,0,0]에서 
board[1] = 2 로 선언하면
퀸이 2번째 행(row=1)에 퀸이 3번째 열(col = 2)에 배치된다는 의미
--------------------
0903
-- 모코 C --
- 4.1 계산하리
산술/대입/비트/쉬프트 연산자, 산술 변환, 우선순위
% >> 나머지 연산자
대입 연산자는 오른쪽부터 진행이 된다 
- 비트 연산자
AND 연산자(&): 둘다 1이어야 1
OR 연산자(|): 하나만 1이어도 1
XOR 연산자(^): 서로 달라야 1
반먼 연산자(~): 0은 1로, 1은 0으로 
쉬프트 연산자(>>): 오른쪽으로 쉬프트 해줌, 왼쪽 맨 앞 수로 추가된 부분이 채워진다 
쉬프트 연산자(<<): 왼쪽으로 쉬프트 해줌 
우선순위 -> 괄호가 1순위니까 괄호만 잘 써주면 된다

- 4.2 컴퓨터가 음수를 표현하는 방법(2의 보수)
2의 보수 표현법, 정수 오버플로우 
- 2의 보수 표현법
>> 맨 앞 비트로 부호를 빠르게 파악 가능
음수, 양수 사이 덧셈 시 부호 고려없이 덧셈 수행 가능

- 2의 보수 만드는 법
비트를 반전 시킨 후에 1을 더함

- 오버플로우
자료형의 최대 표현 범위보다 큰 수를 대입해서 발생하는 문제 
%u >> unsigned 타입으로 해석

-- 바킹독 --
0x03강 - 배열
추가 학습: Cache hit rate
- 0x00. 정의와 성질
자료구조로써의 배열: 메모리 상에 원소를 연속하게 배치한 자료구조 
성질 >> 코테에는 1번만 유념하면 충분 
1. O(1)에 k번째 원소를 확인/변경 가능
2. 추가적으로 소모되는 메모리의 양(=overhead)가 거의 없다
3. Cache hit rate이 높다
4. 메모리 상에 연속한 구간을 잡아야 해서 할당에 제약이 걸린다 

- 0x01. 기능과 구현
1. 기능
임의의 위치에 있는 원소 확인/변경, 
원소를 끝에 추가, 마지막 원소 제거  >>> O(1)
임의의 위치(처음, 마지막 제외)에 원소를 추가/제거 >>> O(N)

2. 구현
insert 함수, erase 함수 

3. 사용팁
전체를 특정 값으로 초기화시킬 때 
1. 그냥 for문 도는 방식 
int a[21]
for (int i =0 : i < 21: i++)
2. (추천) fill 함수 이용
fill(a,a+21,0)
>> 1번째 위치부터 21번째 위치까지 0으로 초기화시킴

- 0x02. STL vector
배열과 동일한 기능을 수행하나
vector의 경우 배열과 다르게 크기를 자유롭게 변경할 수 있음 

- vector에서는 "="을 사용하면 deep copy가 발생하여
v4= v3 같이 선언 하면, 
이후에 v4를 수정해도
v3에는 영향을 미치지 않는다 

- for 문의 다른 표현방식_range-based for loop
vector<int> v1 = {1,2,3,4,5,6};
for (int e:v1)
    cout << e << " ";
>> e에 v1의 원소들이 하나씩 들어가는 for 문임

vector의 size 메소드는
unsigned int 또는 unsigned long long을 반환함
이 때문에 오버플로우가 발생하기도 하므로 주의 

0x03. 연습 문제 
1번. 아스키 코드를 활용하는 방식이 특이함 
string s, s는 입력 받는 값
for (auto c: s)
freq[c-'a']++ 같이 진행하면
c - 'a' = 0~25 사이의 값이 나온다 

2번. 합이 100인 서로 다른 위치의 두 원소가 존재하면 1 존재하지 않으면 0을 반환하는
함수 func2(int arr[], int N)을 작성하라
시간 복잡도는 O(N)으로 제한
즉, 이중 for문 금지 
>>> 배열 활용하는 방법,, 배열을 이중으로쓰면 O(N)으로 처리 가능 

int func2(int arr[], int N){
  int occur[101] = {};
  for(int i = 0; i < N; i++){
    if(occur[100-arr[i]] == 1)
      return 1;
    occur[arr[i]] = 1;
  }
  return 0;
}

-----------
0904
-- 바킹독 연습 문풀 -- 
- 2309_일곱난쟁이
9명 중 키의 합이 100,, 모두 더한 상태에서 2명 빼버리는 구조. 
- 10093_숫자
int 써서 출력 초과 나옴
숫자 범위 때문에 long long을 써야 돌아간다 

----------
0905
-- 알고리즘 문풀 -- 3문제 
- 2750_벡터 형성, 정렬
vector<int> numbers(N);  
// Create a vector to store the numbers
sort(numbers.begin(), numbers.end());
// Sort the numbers in ascending order using std::sort

- 10989_메모리 초과
vector<int> count(10001, 0);

for (int i = 0; i < N; i++) {
    int number;
    cin >> number;
    count[number]++;
}

for (int i = 1; i <= 10000; i++) {
    while (count[i] > 0) {  // Print each number 'count[i]' times
        cout << i << "\n";
        count[i]--;
    }
}

