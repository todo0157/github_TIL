-- 학습 계획 --
주말 >> 배운 내용 정리, 밀린 내용 학습 
시험 기간에는 배운 내용 복습 정도만 가능할듯,, 

알고_주 2~3문제
바킹독_주 1~2강(연습문제도 있음)
C,C++_주 2~3 chapter씩 하기

알고리즘_https://velog.io/@ngngs/%ED%95%9C-%EC%9E%A5%EC%9C%BC%EB%A1%9C-%EB%B3%B4%EB%8A%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98
파트1: 3개, 2: 16개, 3: 16개, 4: 12개
총 47문제
>> 4개월 

바킹독_https://blog.encrypted.gg/919
29강
>> 4개월
문제 링크_https://github.com/encrypted-def/basic-algo-lecture/blob/master/workbook.md
연습 문제_0x03강_처음부터

모코_C,C++_https://modoocode.com/231
C: 21강, C++: 22강
총 45챕터
>> 4개월 
-------------
추가 사이트 
1. 생활 코딩(C/C++은없음)
https://opentutorials.org/course/1

2. SOEN
http://www.soen.kr/
C: 20강, C++: 18강 
3. 파일의 IT 블로그
https://pgh268400.tistory.com/5?category=1072473%20
C 20강

--------------
0909
-- 바킹독 -- 
-0x04강_연결 리스트 
0x00. 정의와 성질
연결 리스트: 원소들을 저장할 때 
그 다음 원소가 있는 위치를 포함시키는 방식으로 저장하는 자료구조

성질 : 
1. k번째 원소를 확인/변경을 위해 O(k)필요
2. 임의의 위치에 원소를 추가/제거는 O(1)
3. 원소들이 메모리상에 연속되어 있지 않아 Cache hit rate가 낮고,
할당은 다소 쉬움
종류: 단일, 이중, 원형 연결 리스트 
추가적으로 필요한 공간(overhead)가 필요함
32비트 컴퓨터의 경우 4N바이트, 
64비트 컴퓨터의 경우 8N바이트가 추가로 필요함

-0x01. 기능과 구현 
임의의 위치에 있는 원소를 확인/변경 = O(N)
임의의 위치에 원소를 추가/제거 = O(1)

연결 리스트의 정석적인 구현은 NODE 구조체나 클래스를 만들어서 
원소가 생성될 때 동적할당하는 방식이나, 코테에는 적절하지 않아서
야매 방식으로 구현하는 거를 봐둬도 나쁘지 않음

- "연결 리스트의 정석적인 구현_NODE 구조체"
struct NODE{
  struct NODE *prev, *next;
  int data;
}

- "야매 연결 리스트"
const int MX = 1000005;
int dat[MX], pre[MX], nxt[MX];
int unused = 1;

fill(pre, pre+MX, -1);
fill(nxt, nxt+MX, -1);

- "traverse, insert, erase 함수 구현해보기" 

-0x02. STL list
push_back, pop_back, push_front, pop_front
>>> 모두 O(1)
"list<int> L = {1,2};
auto t = L.begin();
"
>>> t는 1을 가리키는 중,,,

- 0x03. 연습문제
BOJ 1406: 에디터
손코딩 문제 1~3번
2,3번 다시 체크
2번_중간에 만나는 두 연결 리스트의 시작점들이 주어졌을 때 
만나는 지점을 구하는 방법
3번_주어진 연결 리스트 안에 사이클이 있는지 판단하는 법
>> "Floyd's cycle-finding algorithm" 참고 

-- 모코 -- 
- 5. 문자 입력 받기
"Buffer Overflow"
: 메모리 버퍼의 범위를 초과하여 데이터가 
인접한 메모리를 덮어쓰는 경우를 
나타내는 특정 유형의 오버플로우
>> 보안상 매우 취약하다

"Overflow"
: 정수, 부동소수점 등 저장된 값이
한계를 초과하는 모든 종류의 경우 의미
>>> 잘못된 계산이나 랩 어라운드 동작은 초래할 수 있으나
무조건 보안 위험을 초래하는 것은 아님

"Wrap around"
숫자가 최대값을 초과한 다음
해당 범위의 반대쪽 끝으로 랩 어라운드 하는 상황을
설명하는데 사용되는 용어
ex) 시계가 11시 + 2시간 >> 13시간이 아니라 1시
Integer Overflow, Integer Underflow가 속함

- 마지막 부분 문제 
(9 * celsius / 5) + 32 
--> double 형 연산 수행
이유: int * double >> double 이 나오고
이후 연산도 double 형으로 덮어짐
(9 / 5) * celsius + 32 
--> int 형 연산 수행
이유: 1 * double로, 
이전보다 부정확한 계산이 됨

- 6강. if문
"&"과 "&&"의 차이점
>> &: 비트 사이의 AND 연산
&&: 조건식 사이의 관계 표현, 즉 참, 거짓만 알려줌
&& >> Short Circuit Evaluation(SCE)

||, ! 연산자 
||도 똑같이 SCE적용됨

Review
"공간복잡도"
얼마나 많은 메모리(공간)가 필요한지 측정하는 방법
O(1): 입력 크기에 상관없이
고정된 양의 공간만 필요할 때
O(n): 입력 크기가 커질수록 더 많은 공간이
필요할 때
O(n^2): 필요한 공간이 매우 빠르게 증가할 때,, 

"Floyd's cycle-finding algorithm"
>> 거북이와 토끼 알고리즘이라고도 함
반복되는 항목에 루프(주기)가 있는지 확인하는데
활용
거북이: 한번에 한 걸음씩
토끼: 한번에 두 걸음씩
움직일때, 루프가 있으면 
토끼는 루프 내에서 거북이를 따라잡는다

-- 알고리즘 -- 
- 1181_단어 정렬
unique, compare 함수 이해 필요
그리고, 아래 구문 이해해야함
"
bool compare(const string &a, const string &b){
    if (a.length() != b.length()){
        return a.length() < b.length();
    }
    return a<b;
}
"

"unique" 함수 
vector<int> numbers = {1, 2, 2, 3, 4, 4, 4, 5, 6, 6};  // Sorted vector with consecutive duplicates

auto newEnd = unique(numbers.begin(), numbers.end());
>> newEnd로 중복되지 않는 원소로 이루어진 vector 형성
numbers.erase(newEnd, numbers.end());
>>> numbers = {1,2,3,4,5,6}임

"sort 함수의 활용"
sort(numbers.begin(), numbers.end(), compare), compare는 정의된 함수
sort(numbers.begin(), numbers.end(), [](int a, int b))
>>> sort 함수에서 분류 기준을 둘 수 있음
"핵심" >> compare와 같이 오는 분류 기준의 return 값은 
반드시, boolean값으로 true or false의 값을 가져야함
만약 true 라면 순서 배치를 기존 방식대로 유지하고
false 라면 순서 배치를 반대로 바꿈